<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Stream Viewer - WebRTC</title>
    <style>
        html {
            width: 100%;
            height: 100%;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: Arial, sans-serif;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: none;
            cursor: pointer;
        }

        #video.playing {
            display: block;
        }

        .status {
            position: absolute;
            color: white;
            font-size: 24px;
            text-align: center;
            padding: 20px;
            max-width: 600px;
        }

        .loading {
            color: #4a9eff;
        }

        .error {
            color: #ff4444;
            font-size: 20px;
        }

        .reconnecting {
            color: #ffaa00;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-top: 4px solid #4a9eff;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .debug-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #0f0;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            border-radius: 5px;
            display: none;
            z-index: 100;
        }

        .debug-info.show {
            display: block;
        }

        /* Mute/Unmute button */
        #muteBtn {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            font-size: 24px;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 50;
            transition: all 0.3s ease;
        }

        #muteBtn:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: white;
            transform: scale(1.1);
        }

        #muteBtn.show {
            display: flex;
        }

        #muteBtn.muted {
            background: rgba(255, 68, 68, 0.8);
        }

        /* Click to unmute overlay */
        #unmuteOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 40;
        }

        #unmuteOverlay.show {
            display: flex;
        }

        .unmute-prompt {
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 40px;
            border-radius: 10px;
            text-align: center;
            color: white;
        }

        .unmute-prompt .icon {
            font-size: 48px;
            margin-bottom: 10px;
        }

        .unmute-prompt .text {
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div id="status" class="status loading">
        <div class="spinner"></div>
        <div id="statusText">Connecting to stream...</div>
    </div>
    <video id="video" autoplay playsinline muted></video>

    <!-- Unmute overlay (shown once on first load if not auto-unmuted) -->
    <div id="unmuteOverlay">
        <div class="unmute-prompt">
            <div class="icon">ðŸ”‡</div>
            <div class="text">Click anywhere to enable audio</div>
        </div>
    </div>

    <!-- Mute/Unmute button -->
    <button id="muteBtn" class="muted" title="Toggle Audio">ðŸ”‡</button>

    <div id="debugInfo" class="debug-info"></div>

    <script type="module">
        const video = document.getElementById('video');
        const status = document.getElementById('status');
        const statusText = document.getElementById('statusText');
        const debugInfo = document.getElementById('debugInfo');
        const muteBtn = document.getElementById('muteBtn');
        const unmuteOverlay = document.getElementById('unmuteOverlay');

        // Get stream configuration from URL params, localStorage, or auto-detect
        const urlParams = new URLSearchParams(window.location.search);
        const livestreamConfig = JSON.parse(localStorage.getItem('livestreamConfig') || '{}');

        // Default stream name is 'announcements' (can be overridden via URL param)
        const streamName = urlParams.get('stream') || 'announcements';

        // Auto-unmute option for kiosk mode: ?unmute=1 or ?autoUnmute=1
        const autoUnmute = urlParams.get('unmute') === '1' ||
                          urlParams.get('autoUnmute') === '1' ||
                          urlParams.get('kiosk') === '1';

        // Get WHEP URL:
        // 1. From URL parameter ?server=192.168.1.100:8889 (direct MediaMTX)
        // 2. Use proxy route through main server (recommended for mobile compatibility)
        const directServer = urlParams.get('server');
        const useDirect = urlParams.get('direct') === '1';

        let whepUrl;

        if (directServer) {
            // Direct connection to MediaMTX (for advanced users)
            whepUrl = `http://${directServer}/${streamName}/whep`;
        } else if (useDirect) {
            // Direct connection using current host with MediaMTX port
            const currentHost = window.location.hostname || 'localhost';
            whepUrl = `http://${currentHost}:8889/${streamName}/whep`;
        } else {
            // Default: Use proxy route through main server (port 8080)
            // This works better for mobile devices and avoids port issues
            const origin = window.location.origin;
            whepUrl = `${origin}/stream/${streamName}/whep`;
        }

        let pc = null;
        let restartTimeout = null;
        let sessionUrl = '';
        let hasUserInteracted = false;

        // Debug mode (press 'D' to toggle)
        let debugMode = false;
        document.addEventListener('keydown', (e) => {
            if (e.key === 'd' || e.key === 'D') {
                debugMode = !debugMode;
                debugInfo.classList.toggle('show', debugMode);
            }
            // Press 'M' to toggle mute
            if (e.key === 'm' || e.key === 'M') {
                toggleMute();
            }
        });

        function log(message, type = 'info') {
            console.log(`[${type.toUpperCase()}] ${message}`);
            if (debugMode) {
                const timestamp = new Date().toLocaleTimeString();
                debugInfo.innerHTML += `${timestamp} [${type}] ${message}<br>`;
                debugInfo.scrollTop = debugInfo.scrollHeight;
            }
        }

        function showStatus(message, type = 'loading') {
            status.className = `status ${type}`;
            statusText.textContent = message;
            status.style.display = 'flex';
            status.style.flexDirection = 'column';
            status.style.alignItems = 'center';
        }

        function hideStatus() {
            status.style.display = 'none';
            video.classList.add('playing');
            muteBtn.classList.add('show');

            // Show unmute overlay if muted and user hasn't interacted yet
            if (video.muted && !hasUserInteracted && !autoUnmute) {
                unmuteOverlay.classList.add('show');
            }
        }

        function updateMuteButton() {
            if (video.muted) {
                muteBtn.textContent = 'ðŸ”‡';
                muteBtn.classList.add('muted');
                muteBtn.title = 'Click to Unmute';
            } else {
                muteBtn.textContent = 'ðŸ”Š';
                muteBtn.classList.remove('muted');
                muteBtn.title = 'Click to Mute';
            }
        }

        function toggleMute() {
            video.muted = !video.muted;
            hasUserInteracted = true;
            unmuteOverlay.classList.remove('show');
            updateMuteButton();

            // Save preference
            localStorage.setItem('streamViewerMuted', video.muted ? '1' : '0');
            log(`Audio ${video.muted ? 'muted' : 'unmuted'}`, 'info');
        }

        function unmute() {
            video.muted = false;
            hasUserInteracted = true;
            unmuteOverlay.classList.remove('show');
            updateMuteButton();
            localStorage.setItem('streamViewerMuted', '0');
            log('Audio unmuted', 'info');
        }

        // Click handlers for unmute
        muteBtn.addEventListener('click', toggleMute);
        unmuteOverlay.addEventListener('click', unmute);
        video.addEventListener('click', () => {
            if (video.muted) {
                unmute();
            }
        });

        async function start() {
            log(`Starting WebRTC connection to ${whepUrl}`);
            showStatus('Connecting to stream...', 'loading');

            try {
                // Create RTCPeerConnection with multiple STUN servers for better mobile compatibility
                pc = new RTCPeerConnection({
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' },
                        { urls: 'stun:stun.cloudflare.com:3478' }
                    ],
                    iceCandidatePoolSize: 10
                });

                // Setup event handlers
                pc.oniceconnectionstatechange = () => {
                    log(`ICE connection state: ${pc.iceConnectionState}`, 'info');

                    // Update status for user visibility
                    if (pc.iceConnectionState === 'checking') {
                        showStatus('Establishing connection...', 'loading');
                    } else if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                        log('WebRTC connected successfully!', 'success');
                        hideStatus();

                        // Auto-unmute if enabled (for kiosk mode)
                        if (autoUnmute) {
                            log('Auto-unmute enabled', 'info');
                            // Small delay to ensure video is ready
                            setTimeout(() => {
                                video.muted = false;
                                updateMuteButton();
                            }, 500);
                        }
                    } else if (pc.iceConnectionState === 'failed') {
                        log('WebRTC ICE connection failed', 'error');
                        handleError('Connection failed (ICE). Check network/firewall.');
                    } else if (pc.iceConnectionState === 'disconnected') {
                        showStatus('Connection interrupted. Waiting...', 'reconnecting');
                    } else if (pc.iceConnectionState === 'closed') {
                        log('WebRTC connection closed', 'error');
                        handleError('Connection closed. Reconnecting...');
                    }
                };

                pc.ontrack = (event) => {
                    log(`Received ${event.track.kind} track`, 'success');
                    video.srcObject = event.streams[0];
                };

                // Add transceivers to receive video and audio
                pc.addTransceiver('video', {direction: 'recvonly'});
                pc.addTransceiver('audio', {direction: 'recvonly'});

                // Create offer
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);

                // Wait for ICE gathering (with 2 second timeout for faster connections)
                showStatus('Gathering network info...', 'loading');
                await new Promise((resolve) => {
                    if (pc.iceGatheringState === 'complete') {
                        resolve();
                        return;
                    }

                    // Timeout after 2 seconds - proceed with whatever candidates we have
                    const timeout = setTimeout(() => {
                        log('ICE gathering timeout, proceeding with available candidates', 'info');
                        resolve();
                    }, 2000);

                    const checkState = () => {
                        if (pc.iceGatheringState === 'complete') {
                            clearTimeout(timeout);
                            pc.removeEventListener('icegatheringstatechange', checkState);
                            resolve();
                        }
                    };
                    pc.addEventListener('icegatheringstatechange', checkState);
                });

                // Send offer to MediaMTX WHEP endpoint
                log('Sending WHEP request to server', 'info');
                const response = await fetch(whepUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/sdp',
                    },
                    body: pc.localDescription.sdp,
                });

                if (!response.ok) {
                    throw new Error(`WHEP request failed: ${response.status} ${response.statusText}`);
                }

                // Get session URL from Location header for cleanup
                sessionUrl = new URL(response.headers.get('location'), whepUrl).toString();
                log(`Session created: ${sessionUrl}`, 'success');

                // Set remote description from server's answer
                const answerSdp = await response.text();
                await pc.setRemoteDescription(new RTCSessionDescription({
                    type: 'answer',
                    sdp: answerSdp,
                }));

                log('WebRTC negotiation complete', 'success');

            } catch (error) {
                log(`Error: ${error.message}`, 'error');
                handleError(`Connection error: ${error.message}`);
            }
        }

        function handleError(message) {
            showStatus(message, 'error');
            muteBtn.classList.remove('show');
            unmuteOverlay.classList.remove('show');

            // Cleanup existing connection
            if (pc) {
                pc.close();
                pc = null;
            }

            // Attempt to delete session if it exists
            if (sessionUrl) {
                fetch(sessionUrl, { method: 'DELETE' }).catch(() => {});
                sessionUrl = '';
            }

            // Retry after 3 seconds
            if (restartTimeout) {
                clearTimeout(restartTimeout);
            }

            restartTimeout = setTimeout(() => {
                log('Attempting to reconnect...', 'info');
                showStatus('Reconnecting...', 'reconnecting');
                start();
            }, 3000);
        }

        // Handle page visibility changes to pause/resume
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                log('Page hidden, maintaining connection', 'info');
            } else {
                log('Page visible', 'info');
            }
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (sessionUrl) {
                navigator.sendBeacon(sessionUrl, new Blob([], { type: 'application/json' }));
            }
            if (pc) {
                pc.close();
            }
        });

        // Start streaming
        log('Stream Viewer Initialized (WebRTC/WHEP)', 'info');
        log(`WHEP URL: ${whepUrl}`, 'info');
        log(`Stream: ${streamName}`, 'info');
        log(`Auto-unmute: ${autoUnmute}`, 'info');
        log('Press D to toggle debug info, M to toggle mute', 'info');

        start();
    </script>
</body>
</html>
